#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass article
\begin_preamble



\newtheorem{class}{class or struct}
\newtheorem{type}{type}


\title{MOSES --- A Quick Guide}
\author{Predrag Janicic}
\author{Revised, Linas Vepstas}
\end_preamble
\use_default_options false
\begin_modules
logicalmkup
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\listings_params "basicstyle={\ttfamily},tabsize=3"
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
MOSES - Quick Start
\end_layout

\begin_layout Author
Predrag Janicic, Revised by Linas Vepstas
\end_layout

\begin_layout Date
3 November 2008, revised 30 January 2012
\end_layout

\begin_layout Abstract
Meta-optimizing semantic evolutionary search (MOSES) is a new approach to
 program evolution, based on representation-building and probabilistic modeling.
 MOSES has been successfully applied to solve hard problems in domains such
 as computational biology, sentiment evaluation, and agent control.
 Results tend to be more accurate, and require fewer objective function
 evaluations, than other program evolution systems, such as genetic programming
 or evolutionary programming.
 Best of all, the result of running MOSES is not a large nested structure
 or numerical vector, but a compact and comprehensible program written in
 a simple Lisp-like mini-language.
\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Meta-optimizing semantic evolutionary search (MOSES) is a new approach to
 program evolution, based on representation-building and probabilistic modeling.
 MOSES has been successfully applied to solve hard problems in domains such
 as computational biology, sentiment evaluation, and agent control.
 Results tend to be more accurate, and require fewer objective function
 evaluations, as compared to other program evolution systems.
 Best of all, the result of running MOSES is not a large nested structure
 or numerical vector, but a compact and comprehensible program written in
 a simple Lisp-like mini-language.
 
\end_layout

\begin_layout Standard
This document provides an overview of the core concepts, terminology, algorithm
 and capabilities of MOSES.
 The first few sections provide a general review, suitable for users and
 programmers alike, and should provide sufficient grounding to allow users
 to feel confident in this tool.
 The remiander of the document provides a quick overview of the internal
 structures of the code base, and is intended for programmers interested
 in exploring modified algorithms and extensions.
\end_layout

\begin_layout Standard
The main MOSES website/wiki is located at 
\begin_inset CommandInset href
LatexCommand href
name "http://wiki.opencog.org/w/Meta-Optimizing_Semantic_Evolutionary_Search"
target "http://wiki.opencog.org/w/Meta-Optimizing_Semantic_Evolutionary_Search"

\end_inset

.
 Additional references can be found there, as well as in the References
 section at the end of this paper.
 Moshe Look's PhD thesis 
\begin_inset CommandInset citation
LatexCommand cite
key "6"

\end_inset

 is strongly recommended as primary material for anyone interested in additional
 details.
\end_layout

\begin_layout Section
Copyright Notice
\end_layout

\begin_layout Standard
MOSES is Copyright 2005-2008, Moshe Looks and Novamente LLC.
\end_layout

\begin_layout Standard
It is licensed under the Apache License, Version 2.0 (the "License"); you
 may not use this file except in compliance with the License.
 You may obtain a copy of the License at
\end_layout

\begin_layout Standard
\begin_inset CommandInset href
LatexCommand href
name "http://www.apache.org/licenses/LICENSE-2.0"
target "http://www.apache.org/licenses/LICENSE-2.0"

\end_inset


\end_layout

\begin_layout Standard
Unless required by applicable law or agreed to in writing, software distributed
 under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES
 OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and limitations
 under the License.
\end_layout

\begin_layout Section
Overview
\end_layout

\begin_layout Standard
MOSES performs supervised learning, and thus requires either a scoring function
 or training data to be specified as input.
 As output, it generates a Combo program that, when executed, approximates
 the scoring function.
 MOSES uses general concepts from evolutionary search, in that it maintains
 a population of programs, and then explores the neighborhood of modified,
 "mutated" programs, evaluating their fitness.
 After some number of iterations, the fittest program found is output.
\end_layout

\begin_layout Standard
More precisely, MOSES maintains a population of demes.
 Each deme is a program with many adjustable, tuneable parameters.
 These adjustable parameters are colloquially referred to as knobs.
 Thus, finding the fittest program requires not only selecting a deme, but
 also determining the best settings for the knobs.
\end_layout

\begin_layout Standard
The MOSES algorithm proceeds by selecting a deme and performing random mutations
 on it, by inserting new knobs in various random places.
 The best-possible knob settings for the mutated deme are found by using
 using existing, well-known optimization algorithms, such as hill-climbing,
 simulated annealing or estimation of distribution algorithms (EDA) such
 as Bayesian optimization (BOA/hBOA).
 The fitness of the resulting program(s) can be compared to the fittest
 exemplar of other demes.
 If the new program is found to be more fit, it is used to start a new deme.
 Old dominated demes are discarded, and the process then repeats.
\end_layout

\begin_layout Standard
All program evolution algorithms tend to produce bloated, convoluted, redundant
 programs ("spaghetti code").
 To avoid this, MOSES performs reduction at each stage, to bring the program
 into normal form.
 The specific normalization used is based on Holman's "elegant normal form",
 which mixes alternate layers of linear and non-linear operators.
 The resulting form is far more compact than, say, for example, boolean
 disjunctive or conjunctive normal form.
 Normalization eliminates redundant terms, and tends to make the resulting
 code both more human-readable, and faster to execute.
\end_layout

\begin_layout Standard
The above two techniques, optimization and normalization, allow MOSES to
 out-perform standard genetic programming systems.
 The EDA algorithms, by finding the dependencies in a Bayesian network,
 in fact are able to find how different parts of a program are related.
 This quickly rules out pointless mutations that change one part of a program
 without making corresponding changes in other, related parts of the program.
 The other important ingredient, reduction to normal form, allows programs
 to become smaller, more compact, faster to execute, and more human readable.
 Besides avoiding spaghetti code, normalization removes redundancies in
 programs, thus allowing smaller populations of less complex programs, speeding
 convergence.
\end_layout

\begin_layout Standard
The programs that MOSES generates are "generic", in the sense that MOSES
 works with structured trees, represented in Combo.
 Such trees can represent propositional formula, procedural or functional
 programs, etc.
 The core MOSES solver is written in C++, and takes the form of a library.
 There are many example programs illustrating how to use this library.
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Section
Terminology
\end_layout

\begin_layout Standard
MOSES uses a vocabulary specific to itself.
 Some of the most important terms are defined below.
\end_layout

\begin_layout Description
Program.
 A 
\emph on
program
\emph default
, in MOSES, is a 
\emph on
combo program
\emph default
.
 A combo program is represented as a tree of operators, variables and values.
 Nodes in the tree may be constants (bits, integers, real numbers, 
\emph on
etc.
\emph default
), boolean operators (
\emph on
and, or, etc.
\emph default
), arithmetical operators (+, -, *, 
\emph on
etc.
\emph default
), functions (
\emph on
sin, cos, etc.
\emph default
) or logical expressions (
\emph on
if...then...else, etc.
\emph default
), and so on.
 Arguments to an 
\emph on
n
\emph default
-ary function are denoted with dollars, so that 
\begin_inset Formula $\$1,\$2,\ldots,\$n$
\end_inset

 would be the arguments.
 Thus, for example, 
\begin_inset Formula $(0<(0.5*\$1))\vee\$2$
\end_inset

 is a program that takes argument $1 (a float pt.
 number), multiplies it by 0.5, and checks to see if it is greater than zero.
 The result of this compare is or-ed (
\begin_inset Formula $\vee$
\end_inset

-ed) with argument $2 (a boolean).
 Although programs may be explicit, as in this example, a program can also
 be understood to be a 
\emph on
representation
\emph default
, together with a particular set of 
\emph on
knob settings
\emph default
, as explained below.
\end_layout

\begin_layout Description
Exemplar.
 An 
\emph on
exemplar
\emph default
 is a specific program; typically, the fittest one found.
 
\end_layout

\begin_layout Description
Representation.
 A 
\emph on
representation
\emph default
 is a parameterized tree structure, representing a particular region of
 program space, centered around a single program (the 
\emph on
exemplar
\emph default
).
 A representation is derived from the exemplar by inserting additional nodes
 in various (random) locations.
 The inserted nodes, however, are not specific values or functions or operators,
 but are rather place-holders for values/functions to be determined later.
 Each place-holder may be thought of as a 
\emph on
parameter
\emph default
, and is colloquially referred to as a 
\emph on
knob
\emph default
.
 A representation, together with a particular setting of the knobs, is equivalen
t to a program.
 During the optimization step in MOSES, the space of all possible parameter
 or knob settings will be explored, to locate the best possible settings,
 
\emph on
i.e
\emph default
.
 to find the fittest program.
 
\end_layout

\begin_layout Description
Knobs.
 A 
\emph on
knob
\emph default
 is a single dimension of variation relative to a representation tree.
 It may be discrete or continuous.
 For example, given the program tree fragment 
\begin_inset Formula $(0<(0.5*\$1))\vee\$2$
\end_inset

, a continuous knob might be used to vary the numerical constant 0.5 to other
 values.
 So, setting this knob to 
\begin_inset Formula $0.7$
\end_inset

 would transform this tree fragment to 
\begin_inset Formula $(0<(0.7*\$1))\vee\$2$
\end_inset

.
 Discrete knobs have a '
\emph on
multiplicity
\emph default
': the number of different possible settings they may have.
 Continuous knobs have an effectively infinite multiplicity; in practice,
 however, they are varied in steps of fractional powers of two.
 
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

A discrete knob with a multiplicity of 4 might be used to transform the
 boolean input 
\begin_inset Formula $\$2$
\end_inset

, with 0 meaning 'always true', 1 meaning 'invert', 2 meaning 'don't invert'
 and 3 meaning 'always false'.
 So, setting this knob to 
\begin_inset Formula $1$
\end_inset

 would transform the above example tree to 
\begin_inset Formula $(0<(0.5*\$1))\vee(\neg\$2)$
\end_inset

.
 A discrete knob of multiplicity 6 might be used to replace the less-than
 comparison with 
\begin_inset Formula $\leq,>,\geq,=$
\end_inset

or 
\begin_inset Formula $\ne$
\end_inset

(thus making six possible comparison operators, for a multiplicity of 6
 for this knob).
 Another discrete knob of multiplicity 3 might replace the '
\emph on
or
\emph default
' symbol 
\begin_inset Formula $\vee$
\end_inset

 with the '
\emph on
and
\emph default
' symbol 
\begin_inset Formula $\wedge$
\end_inset

 or the '
\emph on
exclusive-or
\emph default
' symbol 
\begin_inset Formula $\otimes$
\end_inset

.

\emph on
 
\emph default
Knobs do not have to be defined as running over all possible values; it
 is usually convenient to keep multiplicity fairly low.
 This will usually help avoid excess redundancy in program space, although
 resulting programs may be more verbose.
\end_layout

\begin_layout Description
Representation-building.
 The step in the MOSES algorithm where an exemplar is chosen, and a representati
on is constructed from it.
 
\end_layout

\begin_layout Description
Instance.
 An 
\emph on
instance
\emph default
 is an array of particular knob settings.
 For compactness, instances are maintained as strings of bits; the description
 of which bit-fields correspond to which knob settings are kept in separate
 structures, the field set and the knob mapper.
 During optimization, an evolutionary algorithm will pick and choose among
 many different instances; a single field set and knob mapping suffices
 to describe them all.
\end_layout

\begin_layout Description
Field
\begin_inset space ~
\end_inset

set.
 The bits in the instance bit-string are organized into an array of 
\emph on
fields
\emph default
.
 Each field corresponds to a single knob.
 The 
\emph on
field set
\emph default
 describes each field in the array: whether it is discrete or continuous,
 how many settings it may have, 
\emph on
etc
\emph default
.
 The field set is divorced from the representation or any combo program:
 it is merely a listing of possible knobs, but does not indicate where those
 knobs are located in the representation.
\end_layout

\begin_layout Description
Knob
\begin_inset space ~
\end_inset

mapping.
 The 
\emph on
knob mapping
\emph default
 associates each field in a field set with the corresponding knob in the
 representation.
\end_layout

\begin_layout Description
Neighborhood.
 The nearest neighbors of an instance are those other instances that differ
 by exactly one knob setting.
 This is called the 
\emph on
neighborhood at distance one
\emph default
.
 With distance understood as the Hamming distance, one can then consider
 progressively larger neighborhoods: those that differ by just two knob
 settings, or three, 
\emph on
etc
\emph default
.
 
\end_layout

\begin_layout Description
Deme.
 A 
\emph on
deme
\emph default
 is a population of programs derived from one single representation.
 Thus, a deme can be thought of as a population of knob settings.
 During the optimization phase, an optimizer algorithm, such as hill-climbing,
 simulated annealing, or the Bayesian optimization algorithm is used to
 work with the population, locating the best possible knob settings for
 the given representation.
 In practice, in the actual implementation, a deme is just a set of scored
 instances.
 This is because all instances in a deme share the same representation,
 field set and knob mapping.
\end_layout

\begin_layout Description
Metapopulation.
 MOSES maintains a collection of demes, playing each off the others.
 This set of demes is referred to as the 
\emph on
metapopulation
\emph default
.
 Pairs of demes are in competition; fitter demes are used to replace less
 fit demes.
\end_layout

\begin_layout Description
Scoring
\begin_inset space ~
\end_inset

function.
 During the optimization phase, candidate programs being explored are scored
 by a 
\emph on
scoring function
\emph default
.
 The function is specific to the given problem; it returns a value indicating
 how closely the candidate program matched the desired output.
 For supervised training (
\emph on
aka
\emph default
 regression) problems, the scoring function just returns how closely the
 candidate program matched the training set.
 For demonstration problems, the scoring function is typically some well-studied
 toy problem, such as parity, onemax, santa-fe-trail, 
\emph on
etc.

\emph default
 Usually, the perfect score is 
\begin_inset Formula $0$
\end_inset

, while worse scores are negative.
 Fitter programs have higher scores.
\end_layout

\begin_layout Description
Domination.
 One program instance is considered to 
\emph on
dominate
\emph default
 another if it is better in every way.
 The concept of domination requires a scoring function that issues not just
 one grand-total score, but an array of scores.
 For example, for regression problems, a program instance may be judged
 on how accurately it provides an output given an input.
 To test this, one typically provides a table of N input rows, with each
 row indicating a desired output.
 The program can then be tested on each row, with the result compared to
 the desired output value for that row.
 One program is said to 
\emph on
dominate
\emph default
 another only if it has a better score on each of the N tests.
 Typically, two different programs do not dominate one-another: one is better
 for some input rows, while the other is better at others.
 In MOSES, both are kept around and further evolved, with the goal of eventually
 finding a program that dominates all.
 Programs that are completely dominated are (usually) discarded.
\end_layout

\begin_layout Description
Normalization,
\begin_inset space ~
\end_inset

reduction.
 The 
\emph on
normalization
\emph default
 step of the MOSES algorithm takes a program, and simplifies it, using 
\emph on
re-writing rules
\emph default
.
 The resulting program is said to be in 
\emph on
normal form
\emph default
.
 Thus, for example, 
\begin_inset Formula $\$3\vee F$
\end_inset

 can be reduced to just 
\begin_inset Formula $\$3$
\end_inset

 since or-ing with false changes nothing.
 Similarly, 
\begin_inset Formula $0<0.5*\$6$
\end_inset

 can be normalized to 
\begin_inset Formula $0<\$6$
\end_inset

 since multiplying by one-half never changes the sign of a number.
 Likewise, the expression 
\begin_inset Quotes eld
\end_inset


\begin_inset Formula $\mbox{if }(x=x)\mbox{ then }y$
\end_inset


\begin_inset Quotes erd
\end_inset

 can be reduced to 
\begin_inset Formula $y$
\end_inset

, since a value is always equal to itself, and so the if-branch is always
 taken.
 Normalization can sometimes eliminate large parts of a program, if they
 are vacuous or tautological.
 There are many different types of normalization that are possible; MOSES
 always normalizes to the so-called '
\emph on
elegant normal form
\emph default
'.
 The word '
\emph on
reduction
\emph default
' is often used as a synonym for normalization.
\end_layout

\begin_layout Section
MOSES Algorithm
\end_layout

\begin_layout Standard
The MOSES algorithm consists of two nested optimization loops.
 The outer loop maintains a population of scored program trees, the so-called
 '
\emph on
metapopulation
\emph default
'.
 The inner loop explores a local neighborhood of a given program tree, using
 a representation centered on an exemplar.
 When the inner loop finds a reasonable set of candidate programs, these
 are returned to the outer loop, and merged back into the metapopulation.
 More precisely, the steps are as follows:
\end_layout

\begin_layout Enumerate
Selection step.
 Choose one exemplar from the metapopulation.
 Initially, this will be the empty program, unless the user specified an
 initial exemplar.
 The choice is made by considering the entire metapopulation, and picking
 the program tree with the highest score, that has not been previously explored
 (There is little point in re-exploring the neighborhood of a previously
 explored program tree, as all improvements are likely to have already been
 found).
 This selection is done by 
\family typewriter
metapopulation::select_exemplar()
\family default
.
\end_layout

\begin_layout Enumerate
Representation-building step.
 Given an exemplar, construct a representation; that is, take the exemplar
 and decorate it with knobs.
 Build a field set and a knob mapper that will act as a mapping between
 a linear bit-string, and specific knob settings in the representation.
 The field set describes the layout of the bit-string; the knob mapper associate
s fields with knobs.
 Create an initial instance; that is, a bit-string that can be interpreted
 as a collection of knob settings, via the field set mapping.
 
\end_layout

\begin_layout Enumerate
Optimization step.
 Given a representation, a field set, and an initial instance, invoke the
 inner optimization loop.
 One of several different inner optimization loops are possible; they all
 have the steps below in common.
 Typically, a collection of scored instances is maintained; this collection
 is called a '
\emph on
deme
\emph default
', and thus the first step is to '
\emph on
open a new deme
\emph default
'.
\end_layout

\begin_deeper
\begin_layout Enumerate
Score the initial instance: that is, evaluate the combo program that results
 from these specific knob settings, and see how well this program reflects
 the desired regression output.
\end_layout

\begin_layout Enumerate
Generate new instances via some algorithm (
\emph on
e.g.

\emph default
 hill-climbing, simulated annealing, 
\emph on
etc.
\emph default
) and score these instances in turn.
 Maintain a collection of scored instances; these are referred to as the
 
\emph on
deme
\emph default
.
 New instances are typically neighbors of other instances: they differ from
 existing instances by just a few knob settings.
\end_layout

\begin_layout Enumerate
Terminate the search via some exit criteria: lack of improvement, number
 of allowed evaluations exceeded, maximal neighborhood explored, 
\emph on
etc
\emph default
.
\end_layout

\end_deeper
\begin_layout Enumerate
Close the deme.
 This step accept the list of best-possible instances found in the previous
 step, and merges them back into the metapopulation.
 First, convert each instance in the deme back into ordinary program trees
 (
\emph on
i.e.

\emph default
 by fixing knob settings at a set position, thus 'removing' the knobs).
 Normalize, or reduce each of these to 'elegant normal form'.
 Merge the resulting programs into the metapopulation, ranking them by score.
 Merging is performed by considering domination; dominated programs are
 discarded; non-dominated ones are added to the metapopulation.
\end_layout

\begin_layout Enumerate
Go to step 1, repeating until termination criteria are met, such as achieving
 perfect score, or exceeding the maximal number of evaluations, 
\emph on
etc
\emph default
.
\end_layout

\begin_layout Standard
Note that representation-building, the optimization algorithm, and normalization
 are vital steps of the algorithm, and they crucially influence its performance.
 Representation building is specific for each domain (e.g., learning propositional
 formulae), while the optimization algorithm is general (it operates only
 on instances).
 MOSES currently supports representation building for several problem domains,
 including propositional formulae, actions
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
By 
\begin_inset Quotes eld
\end_inset

actions
\begin_inset Quotes erd
\end_inset

 we mean mini programming languages describing actions of a agents such
 as artificial and 
\begin_inset CommandInset citation
LatexCommand cite
key "6"

\end_inset

.
 Available actions typically cover atomic instructions like 
\begin_inset Quotes eld
\end_inset

step forward
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

rotate left
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

rotate right
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

step forward
\begin_inset Quotes erd
\end_inset

, branching instruction such as ,,if-then-else
\begin_inset Quotes eld
\end_inset

, and loop instruction such as ,,while
\begin_inset Quotes eld
\end_inset

.
\end_layout

\end_inset

, arithmetic formulas, and predicate logic (arithmetic relations embedded
 in propositional formulae.
 MOSES also supports several different optimization algorithms, including
 hill-climbing, simulated annealing and Bayesian optimization.
 Work on support-vector machine (SVM) optimization is underway.
 Only one form of program reduction, to elegant normal form, is supported.
 Other types of reduction, e.g.
 SAT-based or satisfiability-modulo-theory (SMT) may be possible but remains
 unexplored.
\end_layout

\begin_layout Section
Installation
\end_layout

\begin_layout Standard
To compile MOSES, you need
\end_layout

\begin_layout Itemize
a recent gcc (4.x or later); 
\end_layout

\begin_layout Itemize
the boost libraries (
\begin_inset CommandInset href
LatexCommand href
name "http://www.boost.org/"
target "http://www.boost.org/"

\end_inset

); 
\end_layout

\begin_layout Itemize
the CMake package (
\begin_inset CommandInset href
LatexCommand href
name "http://www.cmake.org/HTML/Index.html"
target "http://www.cmake.org/HTML/Index.html"

\end_inset

); 
\end_layout

\begin_layout Standard
For compiling MOSES, create a directory 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
build
\end_layout

\end_inset

 (from the root folder of the MOSES distribution), go under it and run 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

cmake ..
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

.
 This will create the needed build files.
 Then, make the project using 
\begin_inset Flex Code
status collapsed

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

make
\begin_inset Quotes erd
\end_inset


\end_layout

\end_inset

 (again from the directory 
\family typewriter
build
\family default
).
 Generated executables will be in the folder 
\family typewriter
build/moses/learning/moses/main
\family default
.
 
\end_layout

\begin_layout Section
Source Files and Folders
\end_layout

\begin_layout Standard
MOSES is implemented in C++ and makes heavy use of templates.
 Modifying MOSES requires familiarity with C++ and, at least to some extent,
 with C++ templates.
\end_layout

\begin_layout Standard
The following folders can be found in the MOSES distribution, under 
\family typewriter
moses/learning/moses
\family default
:
\end_layout

\begin_layout Description
eda This folder contains support for estimation of distribution algorithms,
 and the lower level support for optimization algorithms.
 
\end_layout

\begin_layout Description
example-ant Example implementation of using MOSES to solve for robotic perceptio
n-action algorithms.
 This example demonstrates the "ant on the Santa Fe Trail" problem; it includes
 definitions for the movement of the ant, the perceptions of the ant, and
 the space in which the ant can move.
 Conceptually, the problem is that of finding the best possible algorithm
 for a robot to use to accomplish some task, given that the robot has certain
 limited senses, and certain limited movements.
\end_layout

\begin_layout Description
example-data Contains example data sets, illustrating regression (supervised
 training).
\end_layout

\begin_layout Description
example-progs This folder contains examples demonstrating different features
 of the MOSES system: reducing expressions, and, of course, applications
 of MOSES itself.
 It includes examples for the, for "parity formulae", 
\emph on
etc.
\end_layout

\begin_layout Description
main Contains the main moses executable.
\end_layout

\begin_layout Description
moses This folder contains the core support for MOSES -- including base
 type definitions, and distributed computation support.
 
\end_layout

\begin_layout Description
optimization Contains the main optimization code.
\end_layout

\begin_layout Description
representation Contains code for representation-building, that is, for taking
 an exemplar, attaching knobs to it, and converting the knob settings to
 and from bit-strings that the optimizer expects to work on.
\end_layout

\begin_layout Section
Types, Structures, and Classes
\end_layout

\begin_layout Standard
This section briefly reviews some of the key datatypes and classes found
 in the code.
 MOSES makes heavy use of C++ templating.
 This is done so as to avoid the need for defining base classes, and so
 avoid the need for pervasive use of derived classes and virtual methods.
\end_layout

\begin_layout Subsection
Structured expression trees
\end_layout

\begin_layout Standard
For representing structured expression trees (programs, propositional formulae,
 
\emph on
etc
\emph default
.) MOSES relies on the library ComboReduct.
 In this library, structured expressions are represented by trees of the
 type
\emph on
 
\family typewriter
\emph default
combo tree 
\family default
as follows:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

typedef Util::tree<vertex> combo_tree;
\end_layout

\end_inset

The file 
\family typewriter
comboreduct/combo/vertex.h 
\family default
defines 
\family typewriter
vertex 
\family default
as shown blow.
 It is done this way so that it can capture different sorts of nodes, for
 different, but still fixed, problem domains.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

typedef boost::variant<builtin,
\end_layout

\begin_layout Plain Layout

		wildcard,
\end_layout

\begin_layout Plain Layout

		argument,
\end_layout

\begin_layout Plain Layout

		contint,
\end_layout

\begin_layout Plain Layout

		action,
\end_layout

\begin_layout Plain Layout

		builtinaction,
\end_layout

\begin_layout Plain Layout

		perception,
\end_layout

\begin_layout Plain Layout

		definiteobject,
\end_layout

\begin_layout Plain Layout

		indefiniteobject,
\end_layout

\begin_layout Plain Layout

		message,
\end_layout

\begin_layout Plain Layout

		procedurecall,
\end_layout

\begin_layout Plain Layout

		anntype,
\end_layout

\begin_layout Plain Layout

		actionsymbol> vertex; 
\end_layout

\end_inset

For more information, review the docs provided in the distribution of the
 ComboReduct library.
\end_layout

\begin_layout Subsection
Representation building
\end_layout

\begin_layout Standard
Conceptually, representation building proceeds by selecting a single program
 tree or exemplar, and then building a neighborhood of nearby programs.
 The result is a deme: a population of similar programs, centered upon the
 exemplar.
 After representation building, the optimization step is performed, to find
 the fittest programs in the deme.
\end_layout

\begin_layout Standard
Representation building proceeds in several steps: the exemplar is festooned
 with a set of 'knobs': these are adjustable parameters added to the program
 tree, to alter its operation.
 An exemplar festooned with knobs is called a 
\family typewriter
'representation'
\family default
.
 Each of these steps is reviewed in greater detail, below.
\end_layout

\begin_layout Standard
The representation itself is specified by the 
\family typewriter
class representation
\family default
, given in 
\family typewriter
representation/representation.h
\family default
.
 The structure itself maintains a copy of the exemplar, as well as the collectio
n of knobs used to create the representation.
 Knobs are added to the exemplar by the class constructor.
 The knob mapping relates locations in the representation to fields in the
 field set.
 The field set indicates which bits in the bit-string instance correspond
 to a field.
\end_layout

\begin_layout Standard
The 
\family typewriter
representation
\family default
 class does not maintain the set of possible knob settings (the instances);
 these kept in the deme, and are held elsewhere.
 
\end_layout

\begin_layout Subsection
Knobs
\end_layout

\begin_layout Standard
Knobs represent tunable parameters in a representation.
 In the MOSES implementation, every knob is defined with respect to a particular
 program tree; that is, ever knob has a specific, explicit location in a
 specific, explicit 
\family typewriter
combo_tree
\family default
.
 Knobs are defined in 
\family typewriter
representation/knobs.h
\family default
 and inherit from the base class 
\family typewriter
knob_base
\family default
:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

struct knob_base { 
\end_layout

\begin_layout Plain Layout

	protected:
\end_layout

\begin_layout Plain Layout

		combo_tree& _tr;
\end_layout

\begin_layout Plain Layout

		combo_tree::iterator _loc; // location of knob in tree
\end_layout

\begin_layout Plain Layout

}; 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Knobs may be continuous (
\family typewriter
contin_knob
\family default
) or discrete.
 Discrete knobs have a fixed number of settings, determined at compile time:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

template<int Multiplicity>
\end_layout

\begin_layout Plain Layout

struct discrete_knob : public knob_base {...}; 
\end_layout

\end_inset

although some of the discrete knob settings may be disallowed at runtime,
 effectively decreasing the total multiplicity.
\end_layout

\begin_layout Standard
In general, knobs may be 
\begin_inset Quotes eld
\end_inset

present
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

absent
\begin_inset Quotes erd
\end_inset

.
 XXX The semantics of this is unclear.
 What does this mean? Knobs also have 
\begin_inset Quotes eld
\end_inset

default
\begin_inset Quotes erd
\end_inset

 settings, but the meaning of this setting is also unclear, as the code
 does wonky things with this...
 XXX TODO fix this.
\end_layout

\begin_layout Standard
The 
\family typewriter
logical_subtree_knob
\family default
 is suitable for propositional formulae; it has three possible settings:
 
\emph on
present
\emph default
, 
\emph on
absent
\emph default
, or 
\emph on
negated
\emph default
.
 In 
\family typewriter
simple_action_subtree_knob
\family default
 knobs, a subexpression can be just 
\emph on
present
\emph default
 or 
\emph on
absent
\emph default
.
 In action knobs, a node can have different settings, corresponding to atomic
 or compound actions, sampled as 
\begin_inset Quotes eld
\end_inset

perms
\begin_inset Quotes erd
\end_inset

 in the method 
\family typewriter
build_knobs::sample_action_perms
\family default
.
 XXX more explanation please ...
\end_layout

\begin_layout Standard
Knobs are added to an exemplar using 
\family typewriter
class build_knobs
\family default
 defined in 
\family typewriter
representation/build_knobs.h
\family default
.
\end_layout

\begin_layout Subsection
Packed Knobs, Instances
\end_layout

\begin_layout Standard
In order for knob settings to be efficiently managed by the optimization
 step, they are packed into a bit-string; the bit-string is of type 
\family typewriter
instance
\family default
, declared in 
\family typewriter
eda/eda.h
\family default
 as a vector of ints:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

typedef unsigned int packed_t;
\end_layout

\begin_layout Plain Layout

typedef vector<packed_t> instance;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The class 
\family typewriter
field_set
\family default
 describes the manner in which knobs are packed into the bit string.
 Defined in 
\family typewriter
representation/field_set.h
\family default
, it contains a list of fields with describe the width of a field, and it's
 offset within the bit-string:
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

struct field {
\end_layout

\begin_layout Plain Layout

	width_t width;
\end_layout

\begin_layout Plain Layout

	size_t major_offset, minor_offset;
\end_layout

\begin_layout Plain Layout

};
\end_layout

\end_inset

Fields come in four basic types: continuous, discrete, 
\begin_inset Quotes eld
\end_inset

terms
\begin_inset Quotes erd
\end_inset

, and single-bit booleans.
 Discrete fields represent variables that can take on multiple distinct
 values.
 These typically take several bits to represent; single-bit boolean variables
 are treated distinctly.
 Continuous variables can take on values in the real-number line.
 However, they are not represented by floats or doubles, but rather, are
 represented with a certain binary tree of intervals of the real-number
 line.
 This encoding is used in order to avoid various difficulties that optimization
 algorithms encounter with floats and doubles.
 The rationale and design is further discussed here: 
\begin_inset CommandInset href
LatexCommand href
name "http://code.google.com/p/moses/wiki/ModelingAtomSpaces"
target "http://code.google.com/p/moses/wiki/ModelingAtomSpaces"

\end_inset

.
 
\begin_inset Quotes eld
\end_inset

Term
\begin_inset Quotes erd
\end_inset

 fields refer to the tree structure of term algebras: they can be thought
 of as trees whose nodes are labeled with strings.
 Term algebras, also known as 
\begin_inset Quotes eld
\end_inset

absolutely free algebras
\begin_inset Quotes erd
\end_inset

, are commonly used in logic, category theory, universal algebra and programming
 to represent arbitrary data structures.
 From the standpoint of MOSES, they generalize the binary tree structure
 of the '
\family typewriter
contin
\family default
' variables.
 
\end_layout

\begin_layout Standard
The 
\family typewriter
field_set
\family default
 provides a set of iterators for walking over these four types; the iterators
 can be used to extract and change specific values in the bit-string, in
 the usual fashion.
 That is, dereferencing an iterator gives the value.
 So for example, the 
\family typewriter
disc_iterator
\family default
 can be used to iterate over discrete fields in an instance: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

const_disc_iterator begin_disc(const instance& inst) const;
\end_layout

\begin_layout Plain Layout

const_disc_iterator end_disc(const instance& inst) const; 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

instance_t my_inst = ...;
\end_layout

\begin_layout Plain Layout

const_disc_iterator it = begin_disc(my_inst);
\end_layout

\begin_layout Plain Layout

for ( ; it<end_disc(my_inst); it++) {
\end_layout

\begin_layout Plain Layout

	cout " This is the value: " << *it << endl;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset

Typically, many different instances can be described by the same 
\family typewriter
field_set
\family default
.
 Thus, when an 
\family typewriter
instance_set
\family default
 is defined (see below), one copy of the 
\family typewriter
field_set
\family default
 is kept, to describe all of the instances in an 
\family typewriter
instance_set
\family default
.
\end_layout

\begin_layout Standard
These unpacked fields are associated with actual knobs in a specific 
\family typewriter
combo_tree
\family default
 by means of the 
\family typewriter
knob_mapper
\family default
.
 So, for example
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

typedef std::multimap<field_set::disc_spec, disc_knob> disc_map;
\end_layout

\end_inset

is a map between 
\family typewriter
disc_knob
\family default
's (discrete knobs, which are aware of the 
\family typewriter
combo_tree
\family default
 in which they are located), and 
\family typewriter
disc_spec
\family default
's (knob specifications, which are used by 
\family typewriter
field_set
\family default
 to describe fields in the packed bit-string).
 This map can be used to find a knob value in a packed bit-string, or, conversel
y, given a field, to find the corresponding knob in a 
\family typewriter
combo_tree
\family default
.
 
\end_layout

\begin_layout Subsection
Representation, revisited 
\end_layout

\begin_layout Standard
XXX some details below incorrect.
\end_layout

\begin_layout Standard
The constructor of this structure, builds knobs with respect to the given
 exemplar (by the method 
\family typewriter
build_knobs
\family default
).
\end_layout

\begin_layout Standard
This structure stores the exemplar like a tree (more precisely 
\family typewriter
combo_tree
\family default
).
 This structure has a method for using a given instance to transform the
 exemplar (
\family typewriter
transform
\family default
) providing a new expression tree.
\end_layout

\begin_layout Standard
The structure also has methods for clearing the current version of the exemplar
 (setting all knobs to default values --- zeros) --- 
\family typewriter
clear_exemplar
\family default
, for getting the exemplar --- 
\family typewriter
get_clean_exemplar
\family default
, and for getting the reduced, simplified version of the exemplar 
\family typewriter
get_clean_exemplar
\family default
.
\end_layout

\begin_layout Subsection
Scoring
\end_layout

\begin_layout Standard
The fitness of program trees are ranked with scores.
 There are several types of scores, these are all defined in 
\family typewriter
moses/types.h.
 
\family default
The most basic is
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

typedef float score_t; 
\end_layout

\end_inset

Different programs may be code at different things, and so judging their
 fitness in multiple ways requires a vector: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

typedef std::vector<score_t> behavioral_score;  
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Programs are also scored according to their complexity, so in 
\family typewriter
moses/complexity.h
\family default
 we find: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

typedef int complexity_t;
\end_layout

\end_inset

Composite scores pair up the complexity and the fitness score: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

typedef std::pair<score_t, complexity_t> composite_score; 
\end_layout

\end_inset

 while behavioral composite scores combine the complexity measure with the
 vector: 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

typedef tagged_item<behavioral_score, composite_score>
\end_layout

\begin_layout Plain Layout

	composite_behavioral_score;  
\end_layout

\end_inset


\end_layout

\begin_layout Standard
XXX Disconnect ..
 the optimize() template in eda/optimize.h doesn't take any of these, but
 a generic scoring policy which can return anything (and maintain anything
 internally, by being a class that inherits from unary_function<instance,retval>
 and implementing operator>().
 So.
 ahh explain....
 also, a number of example scoring functions in example-progs/scoring_functions.h
 
\end_layout

\begin_layout Subsection
Demes and Optimization
\end_layout

\begin_layout Standard
At the conceptual level, the optimization algorithms operate on a population
 in a deme, by twiddling knobs until the optimizer finds a program that
 performs well.
 That is, a deme is a collection of knob settings: for evolutionary optimization
 algorithms, it may be thought of as a population: different instances of
 knob settings compete with one-another until a population of the best-possible
 knob settings is found.
\end_layout

\begin_layout Standard
At the practical level, optimization operates on a population of bit-strings,
 and not on abstract 'knob settings'.
 Thus, a necessary step of the MOSES algorithm is to convert such abstract
 knob settings into packed bit strings, and 
\emph on
vice versa
\emph default
.
 This is done during the representation step of the algorithm: knobs were
 inserted into an exemplar, the knobs were mapped to knob specifications,
 and the knob specifications were in-turn mapped to bit-strings.
 The optimization algorithm then tries to find the fittest bit-strings or
 'instances'.
\end_layout

\begin_layout Standard
So, in 
\family typewriter
eda/scoring.h,
\family default
 we find scored instances.
 The higher the score, the fitter the bit-string:
\family typewriter
 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

template<typename ScoreT>
\end_layout

\begin_layout Plain Layout

struct scored_instance :
\end_layout

\begin_layout Plain Layout

	public tagged_item<instance, ScoreT> {...}; 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In 
\family typewriter
representation/instance_set.h 
\family default
we find a collection of scored instances:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

template<typename ScoreT>
\end_layout

\begin_layout Plain Layout

struct instance_set :
\end_layout

\begin_layout Plain Layout

	public vector<scored_instance<ScoreT> > {
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

	protected:
\end_layout

\begin_layout Plain Layout

		const field_set &_fields;
\end_layout

\begin_layout Plain Layout

};  
\end_layout

\end_inset

Note that, in the above, there is a 
\family typewriter
field_set
\family default
 member used to describe how the packed bits in the instance are to be unpacked.
\end_layout

\begin_layout Subsection
The Optimize Template
\end_layout

\begin_layout Standard
These file 
\family typewriter
eda/optimize.h
\family default
 defines a function template that implements a generic evolutionary selection
 algorithm.
 Currently, this template is used to implement only one optimization algorithm,
 the Bayesian univariate algorithm.
 Although MOSES also implements hill-climbing and simulated annealing, neither
 of the latter two make use of this template (although they probably should,
 as otherwise there is a large amount of cut-n-paste code duplication, leading
 to code bloat and making maintenance harder ...) 
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

template <typename ScoreT,
\end_layout

\begin_layout Plain Layout

		typename ScoringPolicy,
\end_layout

\begin_layout Plain Layout

		typename TerminationPolicy,
\end_layout

\begin_layout Plain Layout

		typename SelectionPolicy,
\end_layout

\begin_layout Plain Layout

		typename StructureLearningPolicy,
\end_layout

\begin_layout Plain Layout

		typename ProbsLearningPolicy,
\end_layout

\begin_layout Plain Layout

		typename ReplacementPolicy,
\end_layout

\begin_layout Plain Layout

		typename LoggingPolicy>
\end_layout

\begin_layout Plain Layout

int optimize(instance_set<ScoreT>&, ...);
\end_layout

\end_inset

The algorithm itself is meant to be generic: it is a loop of steps performed
 on a population.
 The different policies determine how the different steps of the algorithm
 are actually carried out.
\end_layout

\begin_layout Standard
Before entering the loop, each individual in the population is scored for
 fitness (using XXX??).
 Inside the loop, the following steps are taken:
\end_layout

\begin_layout Enumerate
A number of individuals are selected, using 
\family typewriter
SelectionPolicy
\family default
.
 The selected individuals will be modeled and then entered into the tournament.
 (XXX what pre-defined selection policies to we have??)
\end_layout

\begin_layout Enumerate
Initialize a model, using the specified 
\family typewriter
StructureLearningPolicy
\family default
.
 Currently, only one policy is pre-defined: 
\family typewriter
univariate()
\family default
, which creates the trivial structure, 
\emph on
viz.

\emph default
 no structure at all.
 The univariate policy assumes no interdependency at all between different
 genes (variables) in the population: its a no-op.
 The BOA policy, (XXX which needs to be ported over from older code XXX),
 will build a full Bayesian network of dependencies.
 
\end_layout

\begin_layout Enumerate
Learn the structure.
 The idea here is that the different variables in the problem are not independen
t, but are related to one-another: this is the 
\begin_inset Quotes eld
\end_inset

structure
\begin_inset Quotes erd
\end_inset

 of the problem.
 This step gives the solver the opportunity to discern that structure.
 So, for example, the Bayesian Optimization Algorithm (BOA) assumes that
 the structure is a network of probabilities, a Bayesian network.
 As this algorithm is generic, any structure learning system may be used;
 that is, this step invokes the
\family typewriter
 StructureLearningPolicy.

\family default
 Only the selected individuals, from step 1, are used for this.
\end_layout

\begin_layout Enumerate
Learn the probability distribution for the selected individuals.
 The learning here is done within the context of the previously learned
 structure.
 Again, the presumption is that, once the dependencies between variables
 are known, then understanding the actual distribution in a population will
 hint at were optimal solutions lie.
 This function is of type 
\family typewriter
ProbsLearningPolicy.
\end_layout

\begin_layout Enumerate
Create a fixed number of new individuals or instances.
 These are created based on the distribution learned in the previous step.
 The goal here is to create more individuals that are likely to have a high
 score.
\end_layout

\begin_layout Enumerate
Score the new individuals, using the 
\family typewriter
ScoringPolicy
\family default
.
 This step determines the fitness of the newly created individuals.
 The scoring policy is, by definition, highly problem-specific.
 A number of different example scoring policies can be found in 
\family typewriter
example-progs/scoring_functions.h
\family default
.
\end_layout

\begin_layout Enumerate
Replace segments of the existing population with the newly created individuals.
 This is done with the 
\family typewriter
ReplacementPolicy
\family default
.
 Several different replacement policies are defined in 
\family typewriter
eda/replacement.h
\family default
: the 
\family typewriter
replace_the_worst()
\family default
 policy unconditionally replaces the lowest-scoring members of the population.
 The 
\family typewriter
rtr_replacement()
\family default
 replaces the most similar members, based on the hamming distance between
 the fields.
\end_layout

\begin_layout Enumerate
Repeat.
 Go to step 1, unless the maximum generation count has been exceeded, or
 if the 
\family typewriter
TerminationPolicy
\family default
 has been met.
 There is no point in iterating if a good-enough solution has already been
 found; the 
\family typewriter
TerminationPolicy
\family default
 determines what is considered to be 
\begin_inset Quotes eld
\end_inset

good enough
\begin_inset Quotes erd
\end_inset

.
 Currently, two types of termination are pre-defined, in 
\family typewriter
eda/termination.h
\family default
: one is 
\family typewriter
terminate_if_gte()
\family default
, which ends when scores exceed a bound, and 
\family typewriter
terminate_if_gte_or_no_improv
\family default
(), which ends when scores exceed a bound, or fail to show improvement.
 
\end_layout

\begin_layout Standard
Note that 
\family typewriter
ScoringPolicy
\family default
 needs to be thread-safe, as it's 
\family typewriter
operator()
\family default
 will be invoked from multiple threads.
\end_layout

\begin_layout Subsection
Metapopulation
\end_layout

\begin_layout Standard
The metapopulation is a set of scored combo trees.
 More precisely, they are scored with composite behavioural scores (or b-scores).
 A 'bscored combo tree' is then just a pair that associates a b-score with
 a tree, defined in the file 
\family typewriter
moses/types.h.

\family default
 
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

typedef tagged_item<combo::combo_tree,
\end_layout

\begin_layout Plain Layout

		composite_behavioral_score> bscored_combo_tree; 
\end_layout

\end_inset

The metapopulation is then a set of scored combo trees, defined in 
\family typewriter
moses/metapopulation.h.

\family default
 More precisely, it is a template, inheriting from the set:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

typedef std::set<bscored_combo_tree> bscored_combo_tree_set;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

template<typename Scoring,
\end_layout

\begin_layout Plain Layout

         typename BScoring,
\end_layout

\begin_layout Plain Layout

         typename Optimization>
\end_layout

\begin_layout Plain Layout

struct metapopulation :
\end_layout

\begin_layout Plain Layout

	public bscored_combo_tree_set {...}; 
\end_layout

\end_inset

The template plays only a small role in this class; it's only purpose is
 to allow generic scoring and optimization algorithms to be used with the
 metapopulation.
\end_layout

\begin_layout Standard
The metapopulation will store expressions (as scored trees) that were encountere
d during the learning process (not all of them; the weak ones, which are
 dominated by existing ones, are usually skipped as non-promising).
\end_layout

\begin_layout Standard
As an example, one can iterate through the metapopulation and print all
 its elements with their scores and complexities in the following way:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

for (const iterator it=begin(); it!=end(); ++it) 
\end_layout

\begin_layout Plain Layout

	cout << gettree(*it) << " " 
\end_layout

\begin_layout Plain Layout

		<< getscore(*it) << " "
\end_layout

\begin_layout Plain Layout

		<< getcomplexity(*it) << endl;
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The metapopulation is updated in iterations.
 In each iteration, one of its elements is selected as an exemplar.
 The exemplar is then used for building a new deme (that will further extend
 the metapopulation).
\end_layout

\begin_layout Subsection
Metaoptimization
\end_layout

\begin_layout Standard
The main metaoptimization step is carried out by the 
\family typewriter
metapopulation::expand()
\family default
 method.
 This method implements three steps: 
\family typewriter
create_deme()
\family default
, followed by 
\family typewriter
optimize_deme()
\family default
, followed by
\family typewriter
 close_deme()
\family default
.
 The 
\family typewriter
optimize_deme()
\family default
 step invokes the low-level optimizer for the deme (i.e.
 invokes either 
\family typewriter
univariate_optimization()
\family default
, 
\family typewriter
simulated_annealing()
\family default
 or 
\family typewriter
iterative_hillclimbing()
\family default
.
\end_layout

\begin_layout Standard
XXX discuss domination.
\end_layout

\begin_layout Subsection
TODO:
\end_layout

\begin_layout Standard
Discuss role of tree_type in knobs.
\end_layout

\begin_layout Section
MOSES: Putting It All Together
\end_layout

\begin_layout Standard
With all components briefly described above, this section discusses how
 are they combined in the MOSES system.
 XXX The contents below are stale, and need to be re-written.
\end_layout

\begin_layout Standard
The main moses method is trivial: it expands the metapopulation in iterations
 until the given number of evaluations or a perfect solution is reached.
 This method is implemented in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|moses/moses.h|
\end_layout

\end_inset

, in several variations (some with additional arguments corresponding to
 available actions and perceptions, just for the action problem domain).
\end_layout

\begin_layout Standard
Typical usage of MOSES starts by providing scoring functions.
 For instance, for learning disjunction propositional formula one can use
 the following declaration (defined in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
verb|moses/scoring_functions.h|
\end_layout

\end_inset

):
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\end_inset

 disjunction scorer; 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
and for solving the ant problem, one can use the following declaration (defined
 in 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
verb|moses/scoring_functions.h|
\end_layout

\end_inset

):
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\end_inset

 antscore scorer; 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Also, the type of expression to be learnt has to be provided 
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
for a detail explanation of the type system used in ComboReduct see the
 doc provided with the distribution of ComboReduct
\end_layout

\end_inset

.
 For instance, for the disjunctive formula, one should use:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\end_inset

 typetree tt(id::lambdatype); tt.appendchildren(tt.begin(),id::booleantype,arity+1
); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
where 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
verb|arity|
\end_layout

\end_inset

 carries the information of the number of propositional variables to be
 considered.
 For the ant problem, one would write:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\end_inset

 typetree tt(id::lambdatype); tt.appendchildren(tt.begin(),id::actionresulttype,1)
; 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Then the metapopulation has to be declared.
 It is instantiated via templates, saying which scoring function, which
 behavioral scoring function, and which optimization algorithm to use.
 As, arguments one has to provide the random generator, the initial exemplar,
 the type tree, simplification procedure, then the scorers and the optimization
 algorithm.
 This is an example for learning the disjunctive formula:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\end_inset

 metapopulation<logicalscore,logicalbscore,univariateoptimization> metapop(rng,
 vtree(id::logicaland),tt,logicalreduction(), logicalscore(scorer,arity,rng),
 logicalbscore(scorer,arity,rng), univariateoptimization(rng)); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
and this is an example for the ant problem:
\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\end_inset

 metapopulation<antscore,antbscore,univariateoptimization> metapop(rng,vtree(id:
:sequentialand),tt,actionreduction(), scorer, bscorer, univariateoptimization(rn
g)); 
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Final Remarks
\end_layout

\begin_layout Standard
While MOSES is not that big a system, it cannot be documented in detail
 in just a few pages.
 However, the descriptions given above should be helpful when one first
 encounters MOSES and tries to use it and modify it.
\end_layout

\begin_layout Standard
Currently, MOSES together with ComboReduct consists of 17 KLOC of .cc files
 and 24 KLOC of header files, as counted by the wc command.
 This includes all comments, copyright notices, example programs and utilities.
 Of this, combo consists of about 18 KLOC while MOSES consists of 22 KLOC.
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "1"

\end_inset

 Moshe Looks, "Scalable Estimation-of-Distribution Program Evolution", Genetic
 and Evolutionary Computation Conference (GECCO), 2007.
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "2"

\end_inset

 Moshe Looks, "On the Behavioral Diversity of Random Programs", Genetic
 and Evolutionary Computation Conference (GECCO), 2007.
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "3"

\end_inset

 Moshe Looks, "Meta-Optimizing Semantic Evolutionary Search", Genetic and
 Evolutionary Computation Conference (GECCO), 2007.
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "4"

\end_inset

 Moshe Looks, Ben Goertzel, Lucio de Souza Coelho, Mauricio Mudado, and
 Cassio Pennachin,"Clustering Gene Expression Data via Mining Ensembles
 of Classification Rules Evolved Using MOSES", Genetic and Evolutionary
 Computation Conference (GECCO), 2007.
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "5"

\end_inset

 Moshe Looks, Ben Goertzel, Lucio de Souza Coelho, Mauricio Mudado, and
 Cassio Pennachin, "Understanding Microarray Data through Applying Competent
 Program Evolution", Genetic and Evolutionary Computation Conference (GECCO),
 2007.
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "6"

\end_inset

 Moshe Looks, "Competent Program Evolution" Doctoral Dissertation, Washington
 University in St.
 Louis, 2006.
\end_layout

\begin_layout Bibliography
\labelwidthstring References
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "7"

\end_inset

 Moshe Looks, "Program Evolution for General Intelligence", Artificial General
 Intelligence Research Institute Workshop (AGIRI), 2006.
 
\end_layout

\end_body
\end_document
